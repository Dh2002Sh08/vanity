import { Worker } from 'worker_threads';
import os from 'os';

export default async function handler(req, res) {
    const { prefix, endpoint = 'https://api.devnet.solana.com', numWorkers = os.cpus().length } = req.query;

    if (!prefix) {
        return res.status(400).json({ error: 'Prefix is required' });
    }

    try {
        const mint = await generateVanityMintSigner(prefix, endpoint, parseInt(numWorkers));
        console.log("Generated Mint Public Key:", mint.publicKey.toString());

        return res.status(200).json({
            publicKey: mint.publicKey.toString(),
            secretKey: Array.from(mint.secretKey)
        });
    } catch (error) {
        console.error('API Error:', error);
        return res.status(500).json({ error: error.message });
    }
}

async function generateVanityMintSigner(targetPrefix, endpoint, numWorkers) {
    return new Promise((resolve, reject) => {
        let found = false;
        const workers = [];
        const startTime = Date.now();

        console.log(`Starting parallel search for vanity token mint with prefix "${targetPrefix}" using ${numWorkers} workers...`);

        for (let i = 0; i < numWorkers; i++) {
            const worker = new Worker('./utils/vanityWorker.js', {
                workerData: { endpoint, targetPrefix } // Pass data directly
            });
            workers.push(worker);

            worker.on('message', (mintData) => {
                if (!found) {
                    found = true;
                    const mint = {
                        publicKey: mintData.publicKey,
                        secretKey: Uint8Array.from(mintData.secretKey)
                    };

                    const duration = (Date.now() - startTime) / 1000;
                    console.log(`\nVanity Token Mint Generated by Worker ${i}!`);
                    console.log("Mint Address:", mint.publicKey);
                    console.log(`Attempts by this worker: ${mintData.attempts}`);
                    console.log(`Search completed in ${duration.toFixed(2)} seconds`);

                    resolve(mint);
                    workers.forEach(w => w.terminate());
                }
            });

            worker.on('error', (err) => {
                if (!found) {
                    console.error(`Worker ${i} error:`, err);
                    reject(new Error(`Worker ${i} error: ${err.message}`));
                }
            });

            worker.on('exit', (code) => {
                if (code !== 0 && !found) {
                    console.error(`Worker ${i} exited with code ${code}`);
                }
            });
        }

        let totalAttempts = 0;
        const progressInterval = setInterval(() => {
            if (!found) {
                totalAttempts += numWorkers * 1000;
                console.log(`Still searching... ~${totalAttempts} attempts across ${numWorkers} workers`);
            } else {
                clearInterval(progressInterval);
            }
        }, 5000);
    });
}